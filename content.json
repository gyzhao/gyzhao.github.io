{"posts":[{"title":"迭代器(Iterators)和生成器(Generator)","text":"迭代器 迭代器（iterator），使用户可在容器对象（container，例如链表或数组）上遍历的对象。 迭代器模式迭代器模式可以让开发者无需了解如何迭代就可以实现迭代操作。Python，C#，Java对该模式都有完备的支持，JavaScript在ECMAScript 6 也将其引入到语言核心中来。 迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现Iterable接口的对象都有一个 Symbol.iterator 属性，该属性引用默认迭代器。默认迭代器就是一个工厂函数，调用后会产生一个实现 Iterator 接口的对象。若一个对象拥有迭代行为该对象就是一个可迭代对象。 可迭代协议(Iterable )和迭代器协议(Iterator)实现Iterable接口要求同时具备两种能力： 支持迭代自我识别能力 带 Symbol.iterator 键（key）的属性，暴露该属性作为”默认迭代器“，并引用一个迭代器工厂函数 创建Iterator 接口的对象的能力 一个迭代器工厂函数，调用这个工厂函数必须返回一个迭代器 迭代器协议（Iterator）是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器API 使用next() 方法再可迭代对象中遍历数据。 实现了Iterable接口的内置类型 字符串 数组 映射 集合 arguments对象 NodeList等DOM集合类型 如代码所示： 12345678910111213141516171819202122232425262728293031let num = 1;let obj = {};// 没有实现了迭代器工厂函数的类型console.log(num[Symbol.iterator]); // undefined console.log(obj[Symbol.iterator]); // undefinedlet str = 'banana';;let arr = [1, 2, 3];let map = new Map();let set = new Set();let element = document.querySelectorAll('div');// 实现了迭代器工厂函数的类型console.log(str[Symbol.iterator]); // ƒ [Symbol.iterator]()console.log(arr[Symbol.iterator]); // ƒ values()console.log(map[Symbol.iterator]); // ƒ entries()console.log(set[Symbol.iterator]); // ƒ values()console.log(element[Symbol.iterator]);// ƒ values()// 调用工厂函数就生成一个迭代器let strIterator = str[Symbol.iterator]();let arrIterator = arr[Symbol.iterator]();let mapIterator = map[Symbol.iterator]();let setIterator = set[Symbol.iterator]();let elementIterator = element[Symbol.iterator]();console.log(strIterator); // StringIteratorconsole.log(arrIterator); // Array Iteratorconsole.log(mapIterator); // MapIteratorconsole.log(setIterator); //SetIteratorconsole.log(elementIterator); //Array Iterator 可迭代对象的语法对于可接受迭代对象的原生语言特性而言，实际编码过程中不需要显式调用这个工厂函数来生成迭代器，这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器。 支持可迭代对象的原生语言结构包括： for-of 循环 数组结构 扩展操作符 Array.from() 创建集合 创建映射 Promise.all() 和Promise.race 接收可由Promise组成的可迭代对象 yield* 操作符，在生成器中使用 如下所示： 123456789101112131415161718192021let arr = ['a', 'b', 'c'];for (const el of arr) { console.log(el);}let [a, b, c] = arr;console.log(a, b, c); // a b clet arr2 = [...arr];console.log(arr2); // clone of arrlet arr3 = Array.from(arr);console.log(arr3); // clone of arrlet set = new Set(arr);console.log(set); // Set(3) {size: 3, a, b, c}let pairs = arr.map((el, i) =&gt; [i, el]);let map = new Map(pairs);console.log(pairs); // [Array(2), Array(2), Array(2)]console.log(map); // Map(3) {size: 3, 0 =&gt; a, 1 =&gt; b, 2 =&gt; c} 自定义迭代器与Iterable接口类似，任何实现了Iterator接口的对象都可以作为迭代器使用，Symbol.iterator 属性引用的工厂函数会返回相同的迭代器。 12345678910111213141516171819202122232425262728293031323334class Counter { constructor(limit = 0) { this.count = 0; this.limit = limit; } [Symbol.iterator]() { // 为了让一个迭代对象开源创建多个迭代器(比如重新执行for...of)，必须每次创建一个迭代器就对应一个新的计数器 // 所以需要把计数器变量放到闭包中 let count = this.count; let limit = this.limit; return { next() { if (count &lt; limit) { return { value: ++count, done: false }; } else { return { done: true }; } } } }}let counter = new Counter(4);for (let c of counter) { console.log(c); if (c &gt; 2) { break; }}//1,2console.log(counter[Symbol.iterator]()); // {next: ƒ}let counter2 = new Counter(5);console.log(counter1[Symbol.iterator] === counter2[Symbol.iterator]); //true 提前终止迭代器可选的 return() 方法(只能返回: {done:true})用户指定在迭代器提前关闭时执行的逻辑。而执行迭代的结构想让迭代器提前关闭，可能包括的情况有： for-of 循环通过 break、continue、return或throw提前退出 结构操作并未消费所有的值 如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Counter { constructor(limit = 0) { this.limit = limit; } [Symbol.iterator]() { let count = 1, limit = this.limit; return { next() { if (count &lt;= limit) { return { value: count++, done: false }; } else { return { done: true }; } }, return() { console.log('Exitng early'); return { done: true }; } }; }}let counter1 = new Counter(5);for (let i of counter1) { if (i &gt; 2) { break; } console.log(i);}// 1,2 提前退出let counter2 = new Counter(5);try { for (let i of counter2) { if (i &gt; 2) { throw new Error('Error'); } console.log(i); }} catch (e) { }// 1,2 提前退出let counter3 = new Counter(5);let [a, b] = counter3;// 1,2 提前退出 如果迭代器没有关闭，那么还可以继续从上次离开的地方继续迭代。数组的迭代器就是不能关闭的： 12345678910111213let arr = [1, 2, 3, 4, 5];let iter = arr[Symbol.iterator]();for (let i of iter) { console.log(i); if (i &gt; 2) break;}//1,2,3for (let i of iter) { console.log(i);}//4,5 生成器函数生成器是一种特殊的函数。最初调用时，生成器函数不执行任何代码，调用之后会返回一个生成器对象(Generator)。生成器对象实现了Iterable 接口，所以可以用于任何消费可迭代对象的地方。生成器的独特之处在于支持 yield 关键字，该关键字能够暂停执行函数。使用yield关键字还可以通过next() 方法接受输入和产出的值。再加上*号之后，yield 关键字可以将跟在它后面的可迭代对象序列化为一连串的值。 📌生成器函数是一种特殊类型的函数。标准类型的函数每次执行的时候都会创建一个新的环境上下文，而生成器的执行环境上下文会暂时挂起并在将来恢复。 通过迭代器对象控制生成器迭代器用于控制生成器的执行。迭代器对象暴露的最基本接口是 next() 方法。该方法开源用来向生成器请求一个值，从而控制生成器。 下面的代码定义了一个生成器函数，生成器函数只会在初次调用next() 方法后开始执行，调用该函数会返回一个生成器对象。该对象一开始处于暂停执行的状态。调用next() 方法会让生成器开始或恢复执行，碰到 yield时会返回，并重新进入暂停状态并且当前函数作用域的状态会被保留。 123456789101112131415function* generatorNum() { yield 1; yield 2;}const gen = generatorNum();console.log(gen); // generatorNum {[[GeneratorState]]: 'suspended'}console.log(gen.next()); // {value: 1, done: false}console.log(gen.next()); // {value: 2, done: false}console.log(gen);// generatorNum {[[GeneratorState]]: 'suspended'}console.log(gen.next()); // {value: undefined, done: true}console.log(gen); // generatorNum {[[GeneratorState]]: 'closed'}// 生成器对象实现了 Iterable 接口，默认的迭代器是自引用的console.log(gen[Symbol.iterator]() === gen); // true 生成器对象作为可迭代对象因为生成器对象也实现了 Iterator 接口，所以可以直接使用可迭代对象的语法： 12345678function* generatorNum() { yield 1; yield 2;}for (let i of generatorNum()) { console.log(i);} 把执行权交给下一个生成器对象yield* 语句可以将当前生成器对象的执行权交给另一个生成器对象。或者说yield* 语句可以迭代一个可迭代的对象： 123456789101112131415161718function* generatorNum() { yield 1; yield 2; // 返回值为 c，如果没有返回值则为 undefined console.log(yield* generatorStr()) yield* [3, 4];}function* generatorStr() { yield 'a'; yield 'b'; return 'c';}for (let i of generatorNum()) { console.log(i);}//1,2,a,b,c,3,4 使用生成器使用生成器生成ID序列下面的例子中记录ID的变量无法在生成器外部被修改，idGenerator 迭代器可以一直向生成器请求新的ID值。生成器会按需计算它们的产生值，这使得它们能够有效的表示一个计算成本很高的序列，如下面的例子所示，如果是普通函数，是不推荐使用 while(true) 循环的，但是生成器函数却不会有问题。 123456789101112function* IdGenerator() { let id = 0; while (true) { yield ++id; }}const idGenerator = IdGenerator();const id1 = idGenerator.next().value;const id2 = idGenerator.next().value;const id3 = idGenerator.next().value;console.log(id1, id2, id3);// 1,2,3 使用 yield* 实现递归算法通过生成器的方式实现的递归我们可以不必依赖回调函数，直接在 for of 中就可以对元素进行操作。同时，使用生成器函数来解耦代码，将生产值的代码(dom节点)和消费值(对dom节点的操作)的代码隔离开 12345678910111213141516171819202122232425262728293031323334353637/** * 生成器递归函数 * @param {*} elelemt */function* DomTaversal(elelemt) { yield elelemt; elelemt = elelemt.firstElementChild; while (elelemt) { yield* DomTaversal(elelemt); elelemt = elelemt.nextElementSibling; }}/** * 普通递归函数 * @param {*} elelemt * @param {*} callback */function TranversalDOM(elelemt, callback) { callback(elelemt); elelemt = elelemt.firstElementChild; while (elelemt) { TranversalDOM(elelemt, callback); elelemt = elelemt.nextElementSibling; }}const root = document.getElementById('root');TranversalDOM(root, (elelemt) =&gt; { console.log(elelemt);});for (let elelemt of DomTaversal(root)) { console.log(elelemt);} 生成器作为默认迭代器因为生成器对象实现了 Iterable接口，而生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器也很适合作为默认迭代器。 123456789101112131415class Foo { constructor() { this.values = [1, 2, 3]; } *[Symbol.iterator]() { yield* this.values; }}const f = new Foo();for (const x of f) { console.log(x);} 与生成器进行交互yield关键字除了可以作为函数中间返回语句使用，yield 还可以作为函数的中间参数使用。也就是说除了可以通过yield 关键字接收从生成器返回的值，还可以向生成器发送值，从而实现双向通信。 📌第一次调用 next() 传入的值不会被使用，因为这次调用是为了开始执行生成器函数。 12345678910111213141516171819202122function* generatorFn(initial) { console.log(initial); // foo const result = yield `A ${initial}`; console.log(result); // baz console.log(yield `B ${initial} ${result}`); // qux}let gen = generatorFn('foo');// 无法通过第一次 next 方法来向生成器传递值// 但是可以通过向生成器传递一个初始值const result1 = gen.next('bar');const result2 = gen.next('baz');const result3 = gen.next('qux');console.log(result1); // {value: 'A foo', done: false}console.log(result2); // {value: 'B foo baz', done: false}console.log(result3); // {value: undefined, done: true}// foo// baz// qux// {value: 'A foo', done: false}// {value: 'B foo baz', done: false}// {value: undefined, done: true} 提前终止生成器与迭代器类似，生成器也有“可关闭”的概念。在生成器中return() 和 throw() 方法都可以用于强制生成器进入关闭状态。 📌与同样实现了 Iterable接口的迭代器对象相比：迭代器的return()方法是可选的，会在提前终止迭代器时被执行。而生成器的对象都有return()方法，而且可以通过它将生成器对象进入关闭状态。 return()方法return() 方法会强制生成器进入关闭状态。提供给 return() 方法的值就是终止迭代器对象的值。 12345678910111213141516171819202122function* generatorFn() { yield* [1, 2, 3];}const g = generatorFn();console.log(g); // generatorFn {[[GeneratorState]]: 'suspended'}// 支持迭代的语言结构会忽略状态为：done:true 的 IteratorResult 内部返回的值console.log(g.return(4)); // {value: 4, done: true}console.log(g); // generatorFn {[[GeneratorState]]: 'closed'}const g2 = generatorFn();for (let x of g2) { if (x &gt; 1) { // break 也可以终止迭代 g2.return(4); } console.log(x);}// 1，2console.log(g2); // generatorFn {[[GeneratorState]]: 'closed'}console.log(g2.next()); // {value: undefined, done: true} throw() 方法throw() 方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭。 123456789101112function* generatorFn() { yield* [1, 2, 3];}const g = generatorFn();console.log(g); // generatorFn {[[GeneratorState]]: 'suspended'}try { g.throw('error');} catch (e) { console.log(e) // error}console.log(g); // generatorFn {[[GeneratorState]]: 'closed'} 如果生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的 yield，如下： 123456789101112131415function* generatorFn() { for (const x of [1, 2, 3]) { try { yield x; } catch (e) { } }}const g = generatorFn();console.log(g); // generatorFn {[[GeneratorState]]: 'suspended'}// 要先执行，后面才能捕获错误console.log(g.next()); // {value: 1, done: false}g.throw('error');console.log(g.next()); // {value: 3, done: false}console.log(g); // generatorFn {[[GeneratorState]]: 'closed'} 📌注意：如果生成器还没有开始执行就调用 throw() 抛出错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。 参考 https://zh.wikipedia.org/wiki/迭代器 https://zh.wikipedia.org/wiki/生成器 迭代协议 - JavaScript | MDN JavaScript 悟道 (豆瓣) JavaScript高级程序设计（第4版） (豆瓣) JavaScript忍者秘籍（第2版） (豆瓣)","link":"/2020/07/13/iterators-generator/"},{"title":"多账户Github SSH Key 管理","text":"前言同一台PC中使用多个SSH Key是一个非常常见的场景，比如说有多个GitHub账户，或者说有需要连接多个不同的Git服务器，比如说Github是存放开源的项目的仓库，而私人的项目可能是放在Bitbucket上的，或者说除了这些还需要连接公司的Git服务器等。这时候我们需要对SSH Key 进行配置才能正确的使我们在多个Git服务器中来去自如。 创建新的SSH key假设现在电脑里面已经存在一个SSH Key了，现在我们使用命令行来新增一个，注意保存时需要定义一个新的名称，不能把原来的SSH Key给覆盖了，具体生成参考Github提供的文档：Generating a new SSH key and adding it to the ssh-agent 创建config文件在.ssh文件夹中创建一个config文件，内容如下所示： 12345678910Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa# 新增加的SSH KeyHost example.github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/example 可以使用ssh命令来测试SSH key的可用性： 12ssh -vT git@github.comssh -vT git@example.github.com 注意大小写，例如：git@github.com，写成：git@Github.com会连接失败。要和config文件中名称一致。 使用新的SSH Keyclone仓库时，只需要将主机名替换为config文件中配置Host的值即可： 1git@github.com:UserName/projectExample.git 修改为： 1git@example.github.com:UserName/projectExample.git 参考&amp;进一步阅读Multiple github accounts ssh config","link":"/2016/04/05/multiple-ssh-config/"},{"title":"Promise 和 async &amp; await","text":"异步是为了优化需要长时间操作。异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。 回调函数回调函数表明异步操作已经完成。作为曾经 JavaScript 中实现异步函数的主要方式。主要存在以下几个不足： 错误处理困难：当任务长期运行，调用回调函数的代码一般不会和开始任务中的同步代码位于同一事件循环周期 连续执行步骤非常棘手：也就是回调地狱的问题 执行并行任务时也有一定复杂度 当异步请求相互依赖时使用回调的方式会导致深度嵌套，会导致经典的回调地狱： 1234567doSomething(function(result) { doSomethingElse(result, function(newResult) { doThirdThing(newResult, function(finalResult) { console.log('Got the final result: ' + finalResult); }, failureCallback); }, failureCallback);}, failureCallback); PromisePromise 是现在 JavaScript 异步编程的基础。**Promise** 对象用于表示一个异步操作的最终完成（或失败）及其结果值。 Promises/A+ 规范Promise 作为异步编程的一种解决方案，它由社区最早提出和实现。ES6 增加了对 Promises/A+ 规范的完善支持，将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise 基础Promise 有下面三种状态： 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。 已兑现（ fulfilled ） ：意味着操作成功完成。 已拒绝（ rejected ） ：意味着操作失败。 待定状态的 Promise 对象要么会通过一个值被兑现，要么会通过一个原因（错误） 被拒绝 。当这些情况之一发生时，我们用 promise的 then 方法排列起来的相关处理程序就会被调用。且过程是不可逆的，一个 promise 只能成功或失败一次。 Promise 的状态是私有的，而且状态也不能被外部代码修改。Promise 特意将异步行为封装起来，从而隔离外部的同步代码。 使用Promise 有以下约定： 在本轮 事件循环 运行完成之前，回调函数是不会被调用的。 即使异步操作已经完成（成功或失败），在这之后通过 then() 添加的回调函数也会被调用。 通过多次调用 then() 可以添加多个回调函数，它们会按照插入顺序进行执行。 Promise() 构造器Promise 构造器主要用于包装不支持 promise（返回值不是 Promise）的函数。构造器接受一个名为 “ executor function “ 的函数。这个函数应当接受两个函数参数。当异步任务成功时，第一个函数（resolve）将被调用，并返回一个值代表成功。当其失败时，第二个函数（reject）将被调用，并返回失败原因（失败原因通常是一个 error 对象）。语法如下： 1new Promise(executor) 一个简单的示例： 123456const await = (ws) =&gt; new Promise((resolve, reject) =&gt; { if (typeof ws !== 'number') { reject(Error('ws must be a number.')); } setTimeout(resolve, ws);}); Promise 的实例方法下面的方法返回的是一个 promise，所以都是可以被 链式调用 （ chaining ）。 Promise.prototype.then为 promise 添加被兑现和被拒绝状态的回调函数，其以回调函数的返回值兑现 promise Promise.prototype.catch被拒绝状态的回调函数，若回调函数被调用，则兑现其返回值，否则兑现原来的 promise 兑现的值 Promise.prototype.finally()将在原 promise 被敲定（无论被兑现还是被拒绝）时被调用 catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。一遇到异常抛出，浏览器就会顺着 Promise 链寻找下一个 onRejected 失败回调函数或者由 .catch() 指定的回调函数。onRejected 处理程序返回的值也会被 Promise.resolve() 包装。 静态方法Promise.resolve() 和 Promise.reject() 是手动创建一个已经 resolve 或者 reject 的 Promise 快捷方法。 Promise.all() 和 Promise.race() 是并行运行异步操作的两个组合式工具。 Promise 扩展ES6 的 Promise 实现有两个特性并没有实现：Promise 取消和进度跟踪。 async/await异步方法并不会立即返回最终的值，而是会返回一个 promise ，以便在未来某个时候把值交给使用者。 async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise async 函数的返回值是一个 Promise 对象。这个 promise 要么会通过一个由 async 函数返回的值被解决，要么会通过一个从 async 函数中抛出的（或其中没有被捕获到的）异常被拒绝。 await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。 Promise 和 async/await异步是为了优化需要长时间操作。异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。 回调函数回调函数表明异步操作已经完成。作为曾经 JavaScript 中实现异步函数的主要方式。主要存在以下几个不足： 错误处理困难：当任务长期运行，调用回调函数的代码一般不会和开始任务中的同步代码位于同一事件循环周期 连续执行步骤非常棘手：也就是回调地狱的问题 执行并行任务时也有一定复杂度 当异步请求相互依赖时使用回调的方式会导致深度嵌套，会导致经典的回调地狱： 1234567doSomething(function(result) { doSomethingElse(result, function(newResult) { doThirdThing(newResult, function(finalResult) { console.log('Got the final result: ' + finalResult); }, failureCallback); }, failureCallback);}, failureCallback); PromisePromise 是现在 JavaScript 异步编程的基础。**** 对象用于表示一个异步操作的最终完成（或失败）及其结果值。 Promises/A+ 规范Promise 作为异步编程的一种解决方案，它由社区最早提出和实现。ES6 增加了对 Promises/A+ 规范的完善支持，将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise 基础Promise 有下面三种状态： 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。 已兑现（**）：意味着操作成功完成。 已拒绝（**）：意味着操作失败。 待定状态的 Promise 对象要么会通过一个值被兑现，要么会通过一个原因（错误）被拒绝。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。且过程是不可逆的，一个 promise 只能成功或失败一次。 📌Promise 的状态是私有的，而且状态也不能被外部代码修改。Promise 特意将异步行为封装起来，从而隔离外部的同步代码。 使用Promise 有以下约定： 在本轮 事件循环 运行完成之前，回调函数是不会被调用的。 即使异步操作已经完成（成功或失败），在这之后通过 then() 添加的回调函数也会被调用。 通过多次调用 then() 可以添加多个回调函数，它们会按照插入顺序进行执行。 Promise() 构造器**** 构造器主要用于包装不支持 promise（返回值不是 Promise）的函数。构造器接受一个名为 “executor function“ 的函数。这个函数应当接受两个函数参数。当异步任务成功时，第一个函数（resolve）将被调用，并返回一个值代表成功。当其失败时，第二个函数（reject）将被调用，并返回失败原因（失败原因通常是一个 error 对象）。语法如下： 1new Promise(executor) 一个简单的示例： 123456const await = (ws) =&gt; new Promise((resolve, reject) =&gt; { if (typeof ws !== 'number') { reject(Error('ws must be a number.')); } setTimeout(resolve, ws);}); Promise 的实例方法下面的方法返回的是一个 promise，所以都是可以被链式调用（chaining）。 Promise.prototype.then&amp;#x20; 为 promise 添加被兑现和被拒绝状态的回调函数，其以回调函数的返回值兑现 promise Promise.prototype.catch 被拒绝状态的回调函数，若回调函数被调用，则兑现其返回值，否则兑现原来的 promise 兑现的值 Promise.prototype.finally() 将在原 promise 被敲定（无论被兑现还是被拒绝）时被调用 catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。一遇到异常抛出，浏览器就会顺着 Promise 链寻找下一个 onRejected 失败回调函数或者由 .catch() 指定的回调函数。onRejected 处理程序返回的值也会被 Promise.resolve() 包装。 静态方法Promise.resolve() 和 Promise.reject() 是手动创建一个已经 resolve 或者 reject 的 Promise 快捷方法。 Promise.all() 和 Promise.race() 是并行运行异步操作的两个组合式工具。 Promise 扩展ES6 的 Promise 实现有两个特性并没有实现：Promise 取消和进度跟踪。 async/await异步方法并不会立即返回最终的值，而是会返回一个 *Promise*，以便在未来某个时候把值交给使用者。 async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise async 函数的返回值是一个 Promise 对象。这个 promise 要么会通过一个由 async 函数返回的值被解决，要么会通过一个从 async 函数中抛出的（或其中没有被捕获到的）异常被拒绝。 await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。 参考https://book.douban.com/subject/35175321/ https://book.douban.com/subject/30143702/ https://web.dev/i18n/zh/promises/ https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await https://es6.ruanyifeng.com/#docs/promise","link":"/2020/08/09/promise-async-await/"},{"title":"软技能：十步学习法","text":"最近看了一本蛮有意思的书《软技能: 代码之外的生存指南》，这本书从: 职业发展， 自我营销，学习，生产力，理财，健身，精神世界这7个维度来诠释作为一个软件开发人应该如何走向自己向往的生活。其中学习的主题，讲述了技术人员如何在当下技术日新月异的时代下更加有富有成效的快速学习，我觉得还挺适合我们技术开发人员的，总体来说就是在掌握适当基础(最小原则)之上如何利用实践来促进自己知识的消化吸收，再通过实践来加深自己对理论的理解。下面是我整理的《十步学习法》笔记，供大家参考： 第一步到第六步：概览全局，设定目标，搜寻资源，创建计划 集中精力完成足够的前期调研，确保自己明确知道学习的内容，以及如何确定自己达成目标，挑选最好的资源来帮助自己实现目标，制定学习计划。 第一步：了解全局首先对需要学习的课题进行一些基础性研究，对该主题有一个全局性的了解。 第二步：确定范围根据自身的需求，决定学习的重点和学习的范围，在此阶段容易犯的一个错误就是：试图解决太大的问题而让自己陷入困境中。结合从第一步中获得的信息，明确自己的学习范围，尽可能的保持专注；同时也需要阐述自己的学习理由来帮助自己界定学习的范围。学习的范围务必大小适当，既能符合学习理由，有能符合自己的时间限制。 第三步：定义目标确定自己的学习目标，明确学习完成后应该达成的效果，根据简明清晰的目标，勾勒出勤奋学习后成功的图景。成功的标准应该是具体的，无二义性的。 第四步：寻找资源尽可能的尝试多种渠道和方式获取尽可能多的和主题相关资源，该阶段无需考虑这些资源的质量。 第五步：创建学习计划需要在最短的时间内找到正确的学习路径，并找到和到达路径中重要的地标。打造自己的学习计划，一个好的方法是观察别人是如何教授你感兴趣的主题的。通览收到到的全部资源，就可以对自己需要那些内容以及如何组织这些内容有更清晰的认识。 第六步：筛选资源对找到的资源进行筛选，挑选出最有价值的几项来帮助你实现自己的目标。 第七步到第十步：循环往复 通过 “学习——实践——掌握——教授”(LDLT)的方式来真正领悟知识。通过掌握恰到好处的基础知识开始，通过动手实践来学习，同时通过自我探索收集问题。之后，掌握了足够多的有用知识。最后，将自己所学教给他人，以此来弥补自己在学习过程中的不足，同时通过深入思考巩固知识。 第七步：开始学习，浅尝辄止专注与掌握自己所需，能在下一步动手操作的最小量的知识。 第八步：动手操作，边玩边学在掌握操作动手最小量的知识的情况下亲自操作和亲身体验。通过在探索和实践过程中，会产生的各种问题。这些问题会引导着你走向真正重要的方向。当回头寻找问题的答案时，不只是这些问题迎刃而解，而且你记得的东西比你学习的东西要多得多，因为你所学到的都是对你很重要的东西。 把那些暂时还没有答案的问题记录下来，在下一步中就会有机会找出这些问题的答案。 第九步：全面掌握，学以致用好奇心是学习特别是自学的重要组成部分。为了有效利用自己选择的资料，为了上一步生产的问题寻求答案（带着问题学习）。不用担心回头再去操作，付出更多，因为这不仅能够让你找到问题的答案，也能让你学习新东西。给自己足够多的时间去深入理解自己的主题，你可以阅读，可以实验，可以观察，也可以操作。试着把自己正在学习的内容与最终目标关联起来。 第十步：乐为人师，融会贯通要想深入掌握一门学问，并且融会贯通，那么必须要做到能够教授给别人，在这一过程中，你要切实刨析并理解自己所学的知识，将其内化到自己的思想；同时，也要用能够让他人理解的方式精心组织这些信息。在这个过程中，你会发现很多自以为明白的知识点，其实并没有你想象的那么透彻。这一过程会将那些以前自己没太明白的东西联系起来，并简化到自己的大脑中已有的信息，将它们浓缩并经常复习。 参考资料 《软技能: 代码之外的生存指南》","link":"/2016/11/07/ten-step-learn-method/"}],"tags":[{"name":"js","slug":"js","link":"/tags/js/"},{"name":"iterator","slug":"iterator","link":"/tags/iterator/"},{"name":"generator","slug":"generator","link":"/tags/generator/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"learning method","slug":"learning-method","link":"/tags/learning-method/"},{"name":"skill","slug":"skill","link":"/tags/skill/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"skills","slug":"skills","link":"/categories/skills/"}],"pages":[{"title":"","text":"About 仓促本身就是最要不得的态度。当你做某件事的时候，一旦想要求快，就表示你再也不关心它，而想去做别的事。 ——《禅与摩托车维修艺术》","link":"/about/index.html"}]}